<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>THREE.js Sphere</title>
    <script src="resources/object-frames.js"></script>
    <script src="resources/pep.min.js"></script>
    <script src="resources/threejs-src/2016/three.min.js"></script>
    <script src="resources/navigation-arrow.js"></script>
    <link rel="stylesheet" type="text/css" href="resources/navigation-arrow.css">
</head>
<body>
<script>
    var camera, scene, renderer;
    var threejsContainerObj;
    var realityInterface;
    var mesh;

    var isProjectionMatrixSet = false;

    var rendererWidth = screen.height;
    var rendererHeight = screen.width;
    var aspectRatio = rendererWidth / rendererHeight;

    var hue = 0;
    var saturation = 0.75;
    var lightness = 0.6;
    
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();

    window.addEventListener('resize', function(event) {
        console.log('resize window', event);
        console.log('innerWidth: ', window.innerWidth);
        console.log('innerHeight: ', window.innerHeight);
        rendererWidth = window.innerWidth;
        rendererHeight = window.innerHeight;
        aspectRatio = rendererWidth / rendererHeight;

        if (camera) {
            camera.aspect = aspectRatio;
            camera.updateProjectionMatrix();
        }

        if (renderer) {
            renderer.setSize( rendererWidth, rendererHeight );
        }
    });

    window.addEventListener('load', function() {
        
        // create a fullscreen webgl renderer for the threejs content and add to the dom
        renderer = new THREE.WebGLRenderer( { alpha: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( rendererWidth, rendererHeight );
        document.body.appendChild( renderer.domElement );

        // create a threejs camera and scene
        camera = new THREE.PerspectiveCamera( 70, aspectRatio, 1, 1000 );
        // camera.up.set(0, 0, 1);
        scene = new THREE.Scene();

        // create a parent 3D object to contain all the three js objects
        // we can apply the marker transform to this object and all of its
        // children objects will be affected
        threejsContainerObj = new THREE.Object3D();
        threejsContainerObj.matrixAutoUpdate = false;
        scene.add(threejsContainerObj);

        // light the scene with a combination of ambient and directional white light
        var ambLight = new THREE.AmbientLight(0x404040);
        scene.add(ambLight);
        var dirLight1 = new THREE.DirectionalLight(0xffffff, 1);
        dirLight1.position.set(100, 100, 100);
        scene.add(dirLight1);
        var dirLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight2.position.set(-100, -100, -100);
        scene.add(dirLight2);

        // add an icosahedron 3d model to the container object 
        var radius = 75;
        var geometry = new THREE.IcosahedronGeometry( radius, 1 );
        var materials = [
            new THREE.MeshPhongMaterial( { color: 0xffffff, shading: THREE.FlatShading, vertexColors: THREE.VertexColors, shininess: 0 } ),
            new THREE.MeshBasicMaterial( { color: 0x000000, shading: THREE.FlatShading, wireframe: true, transparent: true } )
        ];
        mesh = THREE.SceneUtils.createMultiMaterialObject( geometry, materials );
        threejsContainerObj.add( mesh );
        mesh.position.setZ(150);

        // add spotlight for the shadows
        var spotLight = new THREE.SpotLight(0xffffff);
        spotLight.position.set(-30, -30, 150);
        spotLight.castShadow = true;
        mesh.add(spotLight);

        // make the frame fullscreen within the reality editor,
        // and subscribe to the modelview and projection matrices
        realityInterface = new RealityInterface();

        realityInterface.onRealityInterfaceLoaded(function() {
            realityInterface.setFullScreenOn();
            
            /*
            realityInterface.addDevicePoseMatrixListener(function(devicePoseMatrix, projectionMatrix) {
                console.log('devicePoseMatrix: ', devicePoseMatrix);
            });
            
            realityInterface.addGroundPlaneMatrixListener(function(groundPlaneMatrix, projectionMatrix) {
                console.log('groundPlaneMatrix: ', groundPlaneMatrix);
            });
            
            realityInterface.addAllObjectMatricesListener(function(allObjects, projectionMatrix) {
                console.log('allObjects: ', allObjects);
            });
            */

            // whenever we receive new matrices from the editor, update the 3d scene
            realityInterface.addMatrixListener(renderScene);

            realityInterface.setMoveDelay(400);

            // initNavigationArrow(document.querySelector('canvas'), realityInterface, true, touchDecider);

            realityInterface.registerTouchDecider(touchDecider);

            realityInterface.addIsMovingListener(function(e) {
                if (e) {
                    console.log('red ball is moving');
                    hue = 0.3;
                    saturation = 1;
                    // lightness = 0.75;
                } else {
                    console.log('red ball is NOT moving');
                    hue = 0;
                    saturation = 0.75;
                    lightness = 0.6;
                }
            });
        });

    });
    
    function touchDecider(eventData) {
        
        //1. sets the mouse position with a coordinate system where the center
        //   of the screen is the origin
        mouse.x = ( eventData.x / window.innerWidth ) * 2 - 1;
        mouse.y = - ( eventData.y / window.innerHeight ) * 2 + 1;

        //2. set the picking ray from the camera position and mouse coordinates
        raycaster.setFromCamera( mouse, camera );

        //3. compute intersections
        var intersects = raycaster.intersectObjects( scene.children, true );

        return intersects.length > 0;
    }

    // sets them in row-major using a matrix in column-major
    function setMatrixFromArray(matrix, array) {
        matrix.set( array[0], array[4], array[8], array[12],
            array[1], array[5], array[9], array[13],
            array[2], array[6], array[10], array[14],
            array[3], array[7], array[11], array[15]
        );
    }

    // var rotateX = [
    //     1, 0, 0, 0,
    //     0, -1, 0, 0,
    //     0, 0, 1, 0,
    //     0, 0, 0, 1
    // ];

    /**
     * @desc This function multiplies one m16 matrix with a second m16 matrix
     * @param {Array.<number>} m2 - origin matrix to be multiplied with
     * @param {Array.<number>} m1 - second matrix that multiplies.
     * @return {Array.<number>} m16 matrix result of the multiplication
     */
    function multiplyMatrix(m2, m1, r) {
        // var r = [];
        // Cm1che only the current line of the second mm1trix
        r[0] = m2[0] * m1[0] + m2[1] * m1[4] + m2[2] * m1[8] + m2[3] * m1[12];
        r[1] = m2[0] * m1[1] + m2[1] * m1[5] + m2[2] * m1[9] + m2[3] * m1[13];
        r[2] = m2[0] * m1[2] + m2[1] * m1[6] + m2[2] * m1[10] + m2[3] * m1[14];
        r[3] = m2[0] * m1[3] + m2[1] * m1[7] + m2[2] * m1[11] + m2[3] * m1[15];

        r[4] = m2[4] * m1[0] + m2[5] * m1[4] + m2[6] * m1[8] + m2[7] * m1[12];
        r[5] = m2[4] * m1[1] + m2[5] * m1[5] + m2[6] * m1[9] + m2[7] * m1[13];
        r[6] = m2[4] * m1[2] + m2[5] * m1[6] + m2[6] * m1[10] + m2[7] * m1[14];
        r[7] = m2[4] * m1[3] + m2[5] * m1[7] + m2[6] * m1[11] + m2[7] * m1[15];

        r[8] = m2[8] * m1[0] + m2[9] * m1[4] + m2[10] * m1[8] + m2[11] * m1[12];
        r[9] = m2[8] * m1[1] + m2[9] * m1[5] + m2[10] * m1[9] + m2[11] * m1[13];
        r[10] = m2[8] * m1[2] + m2[9] * m1[6] + m2[10] * m1[10] + m2[11] * m1[14];
        r[11] = m2[8] * m1[3] + m2[9] * m1[7] + m2[10] * m1[11] + m2[11] * m1[15];

        r[12] = m2[12] * m1[0] + m2[13] * m1[4] + m2[14] * m1[8] + m2[15] * m1[12];
        r[13] = m2[12] * m1[1] + m2[13] * m1[5] + m2[14] * m1[9] + m2[15] * m1[13];
        r[14] = m2[12] * m1[2] + m2[13] * m1[6] + m2[14] * m1[10] + m2[15] * m1[14];
        r[15] = m2[12] * m1[3] + m2[13] * m1[7] + m2[14] * m1[11] + m2[15] * m1[15];
        // return r;
    };

    function renderScene(modelViewMatrix, projectionMatrix) {
        
        var scaleMatrix = [
            -1, 0, 0, 0,
            0, -1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ];

        var r = [];
        multiplyMatrix(scaleMatrix, modelViewMatrix, r);
        modelViewMatrix = r;
        // console.log(modelView);
        
        // only set the projection matrix for the camera 1 time, since it stays the same
        if (!isProjectionMatrixSet && projectionMatrix.length > 0) {
            // projectionMatrix[0] *= -1;
            setMatrixFromArray(camera.projectionMatrix, projectionMatrix);
            isProjectionMatrixSet = true;
        }

        if (isProjectionMatrixSet) { // don't turn into else statement, both can happen
            // update models with newest values from the reality editor
            mesh.children[0].material.color.setHSL( hue, saturation, lightness );
            // mesh.rotation.x += 0.005; // slow rotation, for aesthetic effect
            // mesh.rotation.y += 0.01;
            // update model view matrix
            setMatrixFromArray(threejsContainerObj.matrix, modelViewMatrix);
            // render the scene
            threejsContainerObj.visible = true;
            renderer.render( scene, camera );
        }
    }

</script>
</body>
</html>
