<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>THREE.js Sphere</title>
    <script src="resources/object-frames.js"></script>
    <script src="resources/pep.min.js"></script>
    <script src="resources/threejs-src/2016/three.min.js"></script>
    <script src="resources/navigation-arrow.js"></script>
    <script src="resources/STLExport.js"></script>


    <link rel="stylesheet" type="text/css" href="resources/navigation-arrow.css">
</head>
<body>
<script>
    var camera, scene, renderer;
    var threejsContainerObj;
    var realityInterface;
    var mesh;

    var isProjectionMatrixSet = false;

    var rendererWidth = screen.height;
    var rendererHeight = screen.width;
    var aspectRatio = rendererWidth / rendererHeight;

    var initialModelRotation;
    var initialDirection;
    var initialTotalRotation = new THREE.Quaternion();

    var projectionMatrixC = new THREE.Matrix4();

    var hue = 0;
    var saturation = 0.75;
    var lightness = 0.6;
    
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();



    window.addEventListener('resize', function(event) {

        rendererWidth = window.innerWidth;
        rendererHeight = window.innerHeight;
        aspectRatio = rendererWidth / rendererHeight;
        
        // console.log(renderer.getSize(), rendererWidth, rendererHeight);

        if (camera) {
            //camera.aspect = window.innerWidth/window.innerHeight;
            //camera.updateProjectionMatrix();
        }

        if (renderer) {
            renderer.setSize( rendererWidth, rendererHeight );
        }

        realityInterface.addMatrixListener(renderScene);

    });

    window.addEventListener('load', function() {

        
        // create a fullscreen webgl renderer for the threejs content and add to the dom
        renderer = new THREE.WebGLRenderer( { alpha: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( rendererWidth, rendererHeight );
        document.body.appendChild( renderer.domElement );

        // create a threejs camera and scene

        camera = new THREE.PerspectiveCamera( 25, aspectRatio, 0.1, 300000 );
        scene = new THREE.Scene();

        // create a parent 3D object to contain all the three js objects
        // we can apply the marker transform to this object and all of its
        // children objects will be affected
        threejsContainerObj = new THREE.Object3D();
        threejsContainerObj.matrixAutoUpdate = false;
        scene.add(threejsContainerObj);

        // light the scene with a combination of ambient and directional white light
        var ambLight = new THREE.AmbientLight(0x404040);
        scene.add(ambLight);
        var dirLight1 = new THREE.DirectionalLight(0xffffff, 1);
        dirLight1.position.set(100, 100, 100);
        scene.add(dirLight1);
        var dirLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight2.position.set(-100, -100, -100);
        scene.add(dirLight2);

        // add an icosahedron 3d model to the container object 
        var radius = 75;
        var geometry = new THREE.IcosahedronGeometry( radius, 1 );
        var materials = [
            new THREE.MeshPhongMaterial( { color: 0xffffff, shading: THREE.FlatShading, vertexColors: THREE.VertexColors, shininess: 0 } ),
            new THREE.MeshBasicMaterial( { color: 0x000000, shading: THREE.FlatShading, wireframe: true, transparent: true } )
        ];
        mesh = THREE.SceneUtils.createMultiMaterialObject( geometry, materials );
        threejsContainerObj.add( mesh );
        mesh.position.setZ(150);
        mesh.updateMatrixWorld();


        // add spotlight for the shadows
        var spotLight = new THREE.SpotLight(0xffffff);
        spotLight.position.set(-30, -30, 150);
        spotLight.castShadow = true;
        mesh.add(spotLight);

        // make the frame fullscreen within the reality editor,
        // and subscribe to the modelview and projection matrices
        realityInterface = new RealityInterface();

        realityInterface.setIOCallback(function() {
            realityInterface.iosObject.on('connect', function(socket){
                // Register role with IOS Server.
                realityInterface.iosObject.emit("clientName", "controller");

                // Send the 3D model to the IOS Server.
                realityInterface.iosObject.emit('model', THREE.STLExport(scene));

                // Update the model position on screen when the user is no longer moving the model.
                setInterval(function(){
                    sendModelPosition(mesh, camera, realityInterface.iosObject);
                }, 300);
            });

            // update the position of the sphere on the canvas when user drags it.
            realityInterface.iosObject.on('modelUpdate', function(data) {

                var containerMatrix = new THREE.Matrix4();
                var containerMatrixCopy = new THREE.Matrix4();
                
                var mPosition = new THREE.Vector3();
                var mRotation = new THREE.Quaternion();
                var mScale = new THREE.Vector3();

                containerMatrix.copy(threejsContainerObj.matrix);
                containerMatrix.multiply(mesh.matrix);
                containerMatrixCopy.copy(threejsContainerObj.matrix);

                var modelRealPosition = new THREE.Vector3();
                var modelRealRotation = new THREE.Quaternion();
                var modelRealScale = new THREE.Vector3();

                containerMatrixCopy.decompose(modelRealPosition, modelRealRotation, modelRealScale);
                containerMatrix.decompose(mPosition, mRotation, mScale);

                data = JSON.parse(data);
                var vFOV = camera.fov * Math.PI / 180; 
                var z = (data.z / (2 * Math.tan( vFOV / 2 ))) ;

                var modelRotation = new THREE.Matrix4();
                modelRotation.set( data.r00, data.r10, data.r20, 0,
                                   data.r01, data.r11, data.r21, 0,
                                   data.r02, data.r12, data.r22, 0,
                                   0,               0,        0, 1 );

             
                var modelQuaternion = new THREE.Quaternion();
                var modelPosition = new THREE.Vector3();
                var modelScale = new THREE.Vector3();

                modelRotation.decompose(modelPosition, modelQuaternion, modelScale);

                if(initialModelRotation === undefined) {
                  initialModelRotation = new THREE.Quaternion();
                  initialModelRotation.copy(mRotation);
                }

                // This is the model's center position on the 2D screen (ignore Z).
                var XY = new THREE.Vector3(data.x,data.y, 1);

                // Unproject the model's position.
                XY.unproject(camera);

                // Turn that into a unit direction vector from the camera's position.
                XY.sub(camera.position);
                XY.normalize();
                console.log('real scale', modelRealScale);

                // Distance along the direction vector is dependent on parameters sent from the phone.
                XY.multiplyScalar(z * modelRealScale.y);

                // Change near plane of Camera to create 'exit' illusion.
                var newNear = XY.length() - (data.cut * (1/data.im));
                //setNewProjectionMatrix(projectionMatrixFrom(25, window.innerWidth/window.innerHeight, newNear, 300000));

                XY.add(camera.position);

                containerMatrixCopy.getInverse(containerMatrixCopy);

                // From global to local rotation.
                containerMatrix.copy(containerMatrixCopy);
                containerMatrix.multiply(modelRotation);
                modelRotation.decompose(modelPosition, modelQuaternion, modelScale);

                // Change position of the model from global to local coordinates.
                XY.applyMatrix4(containerMatrixCopy);
                
                // Place the model at the right position.
                mesh.position.copy(XY);
              
                // Set the model's rotation.
                var initialRotationCopy = new THREE.Quaternion();
                initialRotationCopy.copy(initialModelRotation);
                initialRotationCopy.multiply(modelQuaternion);
                mesh.quaternion.copy(initialRotationCopy);
          });
        });

        realityInterface.onRealityInterfaceLoaded(function() {
            realityInterface.setFullScreenOn();
            realityInterface.setMoveDelay(400);

            // initNavigationArrow(document.querySelector('canvas'), realityInterface, true, touchDecider);

            realityInterface.registerTouchDecider(touchDecider);

            realityInterface.addIsMovingListener(function(e) {
                if (e) {
                    console.log('red ball is moving');
                    hue = 0.3;
                    saturation = 1;
                    // lightness = 0.75;
                } else {
                    console.log('red ball is NOT moving');
                    hue = 0;
                    saturation = 0.75;
                    lightness = 0.6;
                }
            });
        });
    });

    function setNewProjectionMatrix(matrix) {
        // flip the matrix that has been flipped already.
        matrix[0] *= -1;
        setMatrixFromArray(camera.projectionMatrix, matrix);
    }

    function sendModelPosition(model, camera, socket) {
        var containerMatrixCopy = new THREE.Matrix4();
        var cameraMatrixCopy = new THREE.Matrix4();


        cameraMatrixCopy.copy(camera.matrix);
        containerMatrixCopy.copy(threejsContainerObj.matrix);
        containerMatrixCopy.multiply(model.matrix)

        var modelRealPosition = new THREE.Vector3();
        var modelRealRotation = new THREE.Quaternion();
        var modelRealScale = new THREE.Vector3();


        var cameraRealPosition = new THREE.Vector3();
        var cameraRealRotation = new THREE.Quaternion();
        var cameraRealScale = new THREE.Vector3();
        
        containerMatrixCopy.decompose(modelRealPosition, modelRealRotation, modelRealScale);
        cameraMatrixCopy.decompose(cameraRealPosition, cameraRealRotation, cameraRealScale);

        // Update world matrices.
        camera.updateMatrixWorld();
        model.updateMatrixWorld();

        // Get the orientation of the camera.
        var cameraDirection = new THREE.Vector3();
        camera.getWorldDirection( cameraDirection );

        // Get distance of model to camera along the camera's forward vector.
        var modelToCamera = new THREE.Vector3(cameraRealPosition.x - modelRealPosition.x, cameraRealPosition.y - modelRealPosition.y, cameraRealPosition.z - modelRealPosition.z);
        var modelToCameraDot =  cameraDirection.x * modelToCamera.x + cameraDirection.y * modelToCamera.y + cameraDirection.z * modelToCamera.z;
        var distanceToCameraVector = new THREE.Vector3(cameraDirection.x * modelToCameraDot, cameraDirection.y * modelToCameraDot, cameraDirection.z * modelToCameraDot);
        var distanceToCameraMagnitude = Math.sqrt(distanceToCameraVector.x * distanceToCameraVector.x + distanceToCameraVector.y * distanceToCameraVector.y + distanceToCameraVector.z * distanceToCameraVector.z);


        // Send the initial scale factor of the model.
        socket.emit("init", visibleHeightAtZDepth(distanceToCameraMagnitude, camera) / modelRealScale.x);

        // Send the position of the bunny on the 2d screen.
        socket.emit("dist",  toScreenPosition(model,camera) );

        // Obtain camera position, quaternion and scale.
        var cameraPositionCopy = new THREE.Vector3();
        var cameraQuaternionCopy = new THREE.Quaternion();
        var cameraScaleCopy = new THREE.Vector3();
        var cameraMatrix = new THREE.Matrix4();
        cameraMatrix.getInverse(camera.matrixWorldInverse);
        cameraMatrix.decompose(cameraPositionCopy, cameraQuaternionCopy, cameraScaleCopy);

        // Create a transform of with the camera's rotation and zero translation.
        var cameraAtZeroTransform = new THREE.Matrix4();
        cameraAtZeroTransform.compose(new THREE.Vector3(), cameraQuaternionCopy,cameraScaleCopy);

        // Create a transfrom of the model's rotation and zero translation.
        var modelRotationMatrix = new THREE.Matrix4();
        modelRotationMatrix.compose(new THREE.Vector3(), modelRealRotation ,cameraScaleCopy);

        // Calculate the rotation difference between the scene's camera and the model.
        cameraAtZeroTransform.getInverse(cameraAtZeroTransform);
        modelRotationMatrix.premultiply(cameraAtZeroTransform);

        // Compose a rotation matrix for the model and send it.
        var matrixJSON = {};

        matrixJSON["r00"] = Number(modelRotationMatrix.elements[0]);
        matrixJSON["r01"] = Number(modelRotationMatrix.elements[1]);
        matrixJSON["r02"] = Number(modelRotationMatrix.elements[2]);
        matrixJSON["r03"] = Number(modelRotationMatrix.elements[3]);


        matrixJSON["r10"] = Number(modelRotationMatrix.elements[4]);
        matrixJSON["r11"] = Number(modelRotationMatrix.elements[5]);
        matrixJSON["r12"] = Number(modelRotationMatrix.elements[6]);
        matrixJSON["r13"] = Number(modelRotationMatrix.elements[7]);

        matrixJSON["r20"] = Number(modelRotationMatrix.elements[8]);
        matrixJSON["r21"] = Number(modelRotationMatrix.elements[9]);
        matrixJSON["r22"] = Number(modelRotationMatrix.elements[10]);
        matrixJSON["r23"] = Number(modelRotationMatrix.elements[11]);

        matrixJSON["r30"] = Number(modelRotationMatrix.elements[12]);
        matrixJSON["r31"] = Number(modelRotationMatrix.elements[13]);
        matrixJSON["r32"] = Number(modelRotationMatrix.elements[14]);
        matrixJSON["r33"] = Number(modelRotationMatrix.elements[15]);

        socket.emit("matrix", matrixJSON);
    }

    function visibleHeightRatio( camera ){
      const vFOV = camera.fov * Math.PI / 180; 
      return 2 * Math.tan( vFOV / 2 );
    }

     function visibleHeightAtZDepthFov( depth, fov ){
      const vFOV = camera.fov * Math.PI / 180; 
      return 2 * Math.tan( vFOV / 2 ) * Math.abs( depth );
    }

        
    function visibleHeightAtZDepth( depth, camera ){
        console.log('the fov', camera.fov);
      const vFOV = camera.fov * Math.PI / 180; 
      return 2 * Math.tan( vFOV / 2 ) * Math.abs( depth );
    }

    function visibleWidthAtZDepth( depth, camera ) {
      const height = visibleHeightAtZDepth( depth, camera );
      return height * camera.aspect;
    }

    function toScreenPosition(obj, camera)
    {
        var vector = new THREE.Vector3();

        var widthHalf = 0.5*renderer.context.canvas.width;
        var heightHalf = 0.5*renderer.context.canvas.height;

        obj.updateMatrixWorld();
        vector.setFromMatrixPosition(obj.matrixWorld);
        vector.project(camera);

        return { 
            x: vector.x,
            y: vector.y
        };
    };
    
    function touchDecider(eventData) {
        
        //1. sets the mouse position with a coordinate system where the center
        //   of the screen is the origin
        mouse.x = ( eventData.x / window.innerWidth ) * 2 - 1;
        mouse.y = - ( eventData.y / window.innerHeight ) * 2 + 1;

        //2. set the picking ray from the camera position and mouse coordinates
        raycaster.setFromCamera( mouse, camera );

        //3. compute intersections
        var intersects = raycaster.intersectObjects( scene.children, true );

        return intersects.length > 0;
    }

    // sets them in row-major using a matrix in column-major
    function setMatrixFromArray(matrix, array) {
        matrix.set( array[0], array[4], array[8], array[12],
            array[1], array[5], array[9], array[13],
            array[2], array[6], array[10], array[14],
            array[3], array[7], array[11], array[15]
        );
    }

    function projectionMatrixFrom(vFOV, aspect, near, far) {
        var top = near * Math.tan((Math.PI / 180) * 0.5 * vFOV );
        var height = 2 * top;
        var width = aspect * height;
        var left = -0.5 * width;
        return makePerspective( left, left + width, top, top - height, near, far );
    }

    function makePerspective ( left, right, top, bottom, near, far ) {

        var te = [];
        var x = 2 * near / ( right - left );
        var y = 2 * near / ( top - bottom );

        var a = ( right + left ) / ( right - left );
        var b = ( top + bottom ) / ( top - bottom );
        var c = - ( far + near ) / ( far - near );
        var d = - 2 * far * near / ( far - near );

        console.log(x, y, a, b ,c);

        te[ 0 ] = x;    te[ 4 ] = 0;    te[ 8 ] = a;    te[ 12 ] = 0;
        te[ 1 ] = 0;    te[ 5 ] = y;    te[ 9 ] = b;    te[ 13 ] = 0;
        te[ 2 ] = 0;    te[ 6 ] = 0;    te[ 10 ] = c;   te[ 14 ] = d;
        te[ 3 ] = 0;    te[ 7 ] = 0;    te[ 11 ] = - 1; te[ 15 ] = 0;

        return te;

    }

    function renderScene(modelViewMatrix, projectionMatrix) {
        
        // only set the projection matrix for the camera 1 time, since it stays the same
        if (!isProjectionMatrixSet && projectionMatrix.length > 0) {
            setMatrixFromArray(camera.projectionMatrix, projectionMatrix);
            isProjectionMatrixSet = true;
        }

        if (isProjectionMatrixSet) { // don't turn into else statement, both can happen
            // update models with newest values from the reality editor
            mesh.children[0].material.color.setHSL( hue, saturation, lightness );
            setMatrixFromArray(threejsContainerObj.matrix, modelViewMatrix);
            // render the scene
            threejsContainerObj.visible = true;
            renderer.render( scene, camera );
        }
    }

</script>
</body>
</html>
