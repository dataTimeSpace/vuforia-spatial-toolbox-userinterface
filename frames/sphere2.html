<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>THREE.js Sphere</title>
    <script src="objectDefaultFiles/object.js"></script>
    <script src="objectDefaultFiles/pep.min.js"></script>
    <script src="objectDefaultFiles/envelopeContents.js"></script>
    <script src="resources/threejs-src/2018/three.min.js"></script>
    <script src="resources/threejs-src/2018/utils/SceneUtils.js"></script>
    <script src="resources/navigation-arrow.js"></script>
    <script src="resources/STLExport.js"></script>
    <script src="resources/ColladaExporter.js"></script>
    <script src='resources/stl.js'></script>


    <link rel="stylesheet" type="text/css" href="resources/navigation-arrow.css">
</head>
<body>
<script>
    var camera, scene, renderer;
    var threejsContainerObj;
    var realityInterface;
    var mesh;
    var loader = new THREE.STLLoader();

    var box;

    var isProjectionMatrixSet = false;

    var rendererWidth = screen.height;
    var rendererHeight = screen.width;
    var aspectRatio = rendererWidth / rendererHeight;

    var initialModelRotation;
    var initialDirection;
    var initialTotalRotation = new THREE.Quaternion();

    var projectionMatrixC = new THREE.Matrix4();

    var hue = 0;
    var saturation = 0.75;
    var lightness = 0.6;
    
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();



    window.addEventListener('resize', function(event) {

        rendererWidth = window.innerWidth;
        rendererHeight = window.innerHeight;
        aspectRatio = rendererWidth / rendererHeight;
        

        if (camera) {
            //camera.aspect = window.innerWidth/window.innerHeight;
            //camera.updateProjectionMatrix();
        }

        if (renderer) {
            renderer.setSize( rendererWidth, rendererHeight );
        }

        realityInterface.addMatrixListener(renderScene);

    });

    window.addEventListener('load', function() {
        console.log('LOG CALL');
        loader.load('resources/models/gh3.stl', function (geometry) {
            // create a fullscreen webgl renderer for the threejs content and add to the dom
            renderer = new THREE.WebGLRenderer({alpha: true});
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(rendererWidth, rendererHeight);
            document.body.appendChild(renderer.domElement);

            // create a threejs camera and scene

            camera = new THREE.PerspectiveCamera(25, aspectRatio, 0.1, 300000);
            scene = new THREE.Scene();

            // create a parent 3D object to contain all the three js objects
            // we can apply the marker transform to this object and all of its
            // children objects will be affected
            threejsContainerObj = new THREE.Object3D();
            threejsContainerObj.matrixAutoUpdate = false;
            scene.add(threejsContainerObj);

            // light the scene with a combination of ambient and directional white light
            var ambLight = new THREE.AmbientLight(0x404040);
            scene.add(ambLight);
            var dirLight1 = new THREE.DirectionalLight(0xffffff, 1);
            dirLight1.position.set(100, 100, 100);
            scene.add(dirLight1);
            var dirLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight2.position.set(-100, -100, -100);
            scene.add(dirLight2);

            var exporter = new THREE.ColladaExporter();


            // add an icosahedron 3d model to the container object 
            var radius = 75;


            //var geometry = new THREE.IcosahedronGeometry(radius, 1);
            // var materials = [
            //     new THREE.MeshPhongMaterial({
            //         color: 0xffffff,
            //         shading: THREE.FlatShading,
            //         vertexColors: THREE.VertexColors,
            //         shininess: 0,
            //         transparent: true
            //     }),
            //     new THREE.MeshBasicMaterial({
            //         color: 0x000100,
            //         shading: THREE.FlatShading,
            //         wireframe: true,
            //         transparent: true
            //     })
            // ];

            var material = new THREE.MeshNormalMaterial();

            mesh = new THREE.Mesh( geometry, material );
            threejsContainerObj.add(mesh);
            mesh.position.setZ(150);
            // mesh.position.setX(200);
            // mesh.position.setY(-135);


            mesh.updateMatrixWorld();
            console.log('modelito', THREE.STLExportObject(mesh));


            box = addExperimentalCube(threejsContainerObj);
            addExperimentalCubeOuter(threejsContainerObj);

            // add spotlight for the shadows
            var spotLight = new THREE.SpotLight(0xffffff);
            spotLight.position.set(-30, -30, 150);
            spotLight.castShadow = true;
            mesh.add(spotLight);

            // var data = exporter.parse(mesh);
            // console.log(data.data);
            realityInterface.iosObject.emit('model', THREE.STLExportObject(mesh));

        });
            // make the frame fullscreen within the reality editor,
            // and subscribe to the modelview and projection matrices
            realityInterface = new RealityInterface();
            console.log('set up connected here!');

            realityInterface.setIOCallback(function () {
                realityInterface.iosObject.on('connect', function (socket) {
                    // Register role with IOS Server.
                    console.log('got connected here!');
                    realityInterface.iosObject.emit("clientName", "controller");

                    // Send the 3D model to the IOS Server.
                    if(mesh !== undefined)
                        realityInterface.iosObject.emit('model', THREE.STLExportObject(mesh));

                    // Update the model position on screen when the user is no longer moving the model.
                    setInterval(function () {
                        if(mesh !== undefined)
                        sendModelPosition(mesh, camera, realityInterface.iosObject);
                    }, 300);
                });

                realityInterface.iosObject.on('requestModel', function (data) {
                    console.log('model requested');
                    if(mesh !== undefined)
                        realityInterface.iosObject.emit('model', THREE.STLExportObject(mesh));
                    //initialModelRotation = undefined;
                });


                realityInterface.iosObject.on('endedTouch', function (data) {
                    console.log('Ended touch');
                    initialModelRotation = undefined;
                });

                // update the position of the sphere on the canvas when user drags it.
                realityInterface.iosObject.on('modelUpdate', function (data) {

                    mesh.updateMatrixWorld();

                    var containerMatrix = new THREE.Matrix4();
                    var containerMatrixCopy = new THREE.Matrix4();

                    var currentCameraMatrix = new THREE.Matrix4();
                    var modelForCameraMatrix = new THREE.Matrix4();

                    // modelForCameraMatrix.copy(mesh.matrixWorld);
                    // currentCameraMatrix.copy(camera.matrixWorld);

                    // modelForCameraMatrix.extractRotation(modelForCameraMatrix);
                    // currentCameraMatrix.extractRotation(modelForCameraMatrix);
                    // currentCameraMatrix.getInverse(currentCameraMatrix);
                    // modelForCameraMatrix.premultiply(currentCameraMatrix);


                    var mPosition = new THREE.Vector3();
                    var mRotation = new THREE.Quaternion();
                    var mScale = new THREE.Vector3();

                    containerMatrix.copy(mesh.matrix);
                    //containerMatrix.multiply(mesh.matrix);
                    containerMatrixCopy.copy(threejsContainerObj.matrix);

                    var modelRealPosition = new THREE.Vector3();
                    var modelRealRotation = new THREE.Quaternion();
                    var modelRealScale = new THREE.Vector3();

                    containerMatrixCopy.decompose(modelRealPosition, modelRealRotation, modelRealScale);
                    containerMatrix.decompose(mPosition, mRotation, mScale);

                    data = JSON.parse(data);
                    var vFOV = camera.fov * Math.PI / 180;
                    var z = (data.z / (2 * Math.tan(vFOV / 2)));

                    var modelRotation = new THREE.Matrix4();
                    modelRotation.set(data.r00, data.r10, data.r20, 0,
                        data.r01, data.r11, data.r21, 0,
                        data.r02, data.r12, data.r22, 0,
                        0, 0, 0, 1);

                    var rotation = new THREE.Matrix4().makeRotationZ(Math.PI);


                    var modelQuaternion = new THREE.Quaternion();
                    var modelPosition = new THREE.Vector3();
                    var modelScale = new THREE.Vector3();

                    modelRotation.decompose(modelPosition, mRotation, modelScale);

                    if (initialModelRotation === undefined) {
                        console.log('initializing rotation again');

                        var initialMatrix = new THREE.Matrix4();
                        var cM = new THREE.Matrix4();
                        cM.getInverse(threejsContainerObj.matrix);
                        initialMatrix.copy(mesh.matrixWorld);
                        initialMatrix.premultiply(rotation);
                        initialMatrix.premultiply(cM);
                        console.log('initial matrix is', initialMatrix);
                        initialModelRotation = new THREE.Quaternion();

                        var quat = new THREE.Quaternion();
                        initialModelRotation.copy(mesh.quaternion);
                        // quat.setFromRotationMatrix(rotation);
                        // initialModelRotation.multiply(quat);
                    }

                    // This is the model's center position on the 2D screen (ignore Z).
                    var XY = new THREE.Vector3(data.x, data.y, 1);

                    // Unproject the model's position.
                    XY.unproject(camera);

                    // Turn that into a unit direction vector from the camera's position.
                    XY.sub(camera.position);
                    XY.normalize();

                    // Distance along the direction vector is dependent on parameters sent from the phone.
                    XY.multiplyScalar(z * modelRealScale.y);

                    // Change near plane of Camera to create 'exit' illusion.
                    var newNear = XY.length() - (data.cut * (modelRealScale.z / data.im));
                    setNewProjectionMatrix(projectionMatrixFrom(25, -window.innerWidth / window.innerHeight, newNear, 300000));

                    XY.add(camera.position);

                    containerMatrixCopy.getInverse(containerMatrixCopy);

                    // From global to local rotation.
                    containerMatrix.copy(containerMatrixCopy);
                    //\\containerMatrix.premultiply(rotation);
                    containerMatrix.multiply(modelRotation);
                    //containerMatrix.premultiply(rotation);
                    //modelRotation.premultiply(rotation);
                    modelRotation.decompose(modelPosition, modelQuaternion, modelScale);

                    // Change position of the model from global to local coordinates.
                    XY.applyMatrix4(containerMatrixCopy);

                    // Place the model at the right position.
                    mesh.position.copy(XY);

                    // Set the model's rotation.
                    var initialRotationCopy = new THREE.Quaternion();
                    initialRotationCopy.copy(initialModelRotation);
                    initialRotationCopy.multiply(modelQuaternion);
                    mesh.quaternion.copy(initialRotationCopy);
                    mesh.updateMatrixWorld();
                });
            });

        

            realityInterface.onRealityInterfaceLoaded(function () {
                realityInterface.setFullScreenOn();
                realityInterface.setMoveDelay(400);

                // initNavigationArrow(document.querySelector('canvas'), realityInterface, true, touchDecider);

                realityInterface.registerTouchDecider(touchDecider);

                realityInterface.addIsMovingListener(function (e) {
                    if (e) {
                        console.log('red ball is moving');
                        hue = 0.3;
                        saturation = 1;
                        // lightness = 0.75;
                    } else {
                        console.log('red ball is NOT moving');
                        hue = 0;
                        saturation = 0.75;
                        lightness = 0.6;
                    }
                });
            });

        
    });
    
    function setNewProjectionMatrix(matrix) {
        // flip the matrix that has been flipped already.
        matrix[5] *= -1;
        setMatrixFromArray(camera.projectionMatrix, matrix);
    }

    function sendModelPosition(model, camera, socket) {
        var containerMatrixCopy = new THREE.Matrix4();
        var cameraMatrixCopy = new THREE.Matrix4();

        // Update world matrices.
        //camera.updateMatrixWorld();
        //model.updateMatrixWorld();

        cameraMatrixCopy.copy(camera.matrix);
        containerMatrixCopy.copy(threejsContainerObj.matrix);
        containerMatrixCopy.multiply(model.matrix);



        //containerMatrixCopy.multiply(model.matrix)

        var modelRealPosition = new THREE.Vector3();
        var modelRealRotation = new THREE.Quaternion();
        var modelRealScale = new THREE.Vector3();


        var cameraRealPosition = new THREE.Vector3();
        var cameraRealRotation = new THREE.Quaternion();
        var cameraRealScale = new THREE.Vector3();
        
        containerMatrixCopy.decompose(modelRealPosition, modelRealRotation, modelRealScale);
        cameraMatrixCopy.decompose(cameraRealPosition, cameraRealRotation, cameraRealScale);

     

        // Get the orientation of the camera.
        var cameraDirection = new THREE.Vector3();
        camera.getWorldDirection( cameraDirection );

        // Get distance of model to camera along the camera's forward vector.
        var modelToCamera = new THREE.Vector3(cameraRealPosition.x - modelRealPosition.x, cameraRealPosition.y - modelRealPosition.y, cameraRealPosition.z - modelRealPosition.z);
        var modelToCameraDot =  cameraDirection.x * modelToCamera.x + cameraDirection.y * modelToCamera.y + cameraDirection.z * modelToCamera.z;
        var distanceToCameraVector = new THREE.Vector3(cameraDirection.x * modelToCameraDot, cameraDirection.y * modelToCameraDot, cameraDirection.z * modelToCameraDot);
        var distanceToCameraMagnitude = Math.sqrt(distanceToCameraVector.x * distanceToCameraVector.x + distanceToCameraVector.y * distanceToCameraVector.y + distanceToCameraVector.z * distanceToCameraVector.z);


        // Send the initial scale factor of the model.
        socket.emit("init", visibleHeightAtZDepth(distanceToCameraMagnitude, camera) / modelRealScale.x);

        // Send the position of the bunny on the 2d screen.
        socket.emit("dist",  toScreenPosition(model,camera) );

        // Obtain camera position, quaternion and scale.
        var cameraPositionCopy = new THREE.Vector3();
        var cameraQuaternionCopy = new THREE.Quaternion();
        var cameraScaleCopy = new THREE.Vector3();
        var cameraMatrix = new THREE.Matrix4();
        cameraMatrix.copy(camera.matrixWorld);
        cameraMatrix.decompose(cameraPositionCopy, cameraQuaternionCopy, cameraScaleCopy);

        // Create a transform of with the camera's rotation and zero translation.
        var cameraAtZeroTransform = new THREE.Matrix4();
        cameraAtZeroTransform.compose(new THREE.Vector3(), cameraQuaternionCopy, cameraScaleCopy);

        // Create a transfrom of the model's rotation and zero translation.
        var modelRotationMatrix = new THREE.Matrix4();
        modelRotationMatrix.compose(new THREE.Vector3(), modelRealRotation ,cameraScaleCopy);

        //modelRotationMatrix.extractRotation(modelRotationMatrix);


        // Calculate the rotation difference between the scene's camera and the model.
        cameraAtZeroTransform.getInverse(cameraAtZeroTransform);
        modelRotationMatrix.premultiply(cameraAtZeroTransform);

        var rotation = new THREE.Matrix4().makeRotationZ(Math.PI);
        modelRotationMatrix.premultiply(rotation);

        // Compose a rotation matrix for the model and send it.
        var matrixJSON = {};

        matrixJSON["r00"] = Number(modelRotationMatrix.elements[0]);
        matrixJSON["r01"] = Number(modelRotationMatrix.elements[1]);
        matrixJSON["r02"] = Number(modelRotationMatrix.elements[2]);
        matrixJSON["r03"] = Number(modelRotationMatrix.elements[3]);


        matrixJSON["r10"] = Number(modelRotationMatrix.elements[4]);
        matrixJSON["r11"] = Number(modelRotationMatrix.elements[5]);
        matrixJSON["r12"] = Number(modelRotationMatrix.elements[6]);
        matrixJSON["r13"] = Number(modelRotationMatrix.elements[7]);

        matrixJSON["r20"] = Number(modelRotationMatrix.elements[8]);
        matrixJSON["r21"] = Number(modelRotationMatrix.elements[9]);
        matrixJSON["r22"] = Number(modelRotationMatrix.elements[10]);
        matrixJSON["r23"] = Number(modelRotationMatrix.elements[11]);

        matrixJSON["r30"] = Number(modelRotationMatrix.elements[12]);
        matrixJSON["r31"] = Number(modelRotationMatrix.elements[13]);
        matrixJSON["r32"] = Number(modelRotationMatrix.elements[14]);
        matrixJSON["r33"] = Number(modelRotationMatrix.elements[15]);

        socket.emit("matrix", matrixJSON);
    }

    function visibleHeightRatio( camera ){
      const vFOV = camera.fov * Math.PI / 180; 
      return 2 * Math.tan( vFOV / 2 );
    }

     function visibleHeightAtZDepthFov( depth, fov ){
      const vFOV = camera.fov * Math.PI / 180; 
      return 2 * Math.tan( vFOV / 2 ) * Math.abs( depth );
    }

        
    function visibleHeightAtZDepth( depth, camera ){
      const vFOV = camera.fov * Math.PI / 180; 
      return 2 * Math.tan( vFOV / 2 ) * Math.abs( depth );
    }

    function visibleWidthAtZDepth( depth, camera ) {
      const height = visibleHeightAtZDepth( depth, camera );
      return height * camera.aspect;
    }

    function toScreenPosition(obj, camera)
    {
        var vector = new THREE.Vector3();

        var widthHalf = 0.5*renderer.context.canvas.width;
        var heightHalf = 0.5*renderer.context.canvas.height;

        obj.updateMatrixWorld();
        vector.setFromMatrixPosition(obj.matrixWorld);
        vector.project(camera);

        return { 
            x: vector.x,
            y: vector.y
        };
    };
    
    function touchDecider(eventData) {
        
        //1. sets the mouse position with a coordinate system where the center
        //   of the screen is the origin
        mouse.x = ( eventData.x / window.innerWidth ) * 2 - 1;
        mouse.y = - ( eventData.y / window.innerHeight ) * 2 + 1;

        //2. set the picking ray from the camera position and mouse coordinates
        raycaster.setFromCamera( mouse, camera );

        //3. compute intersections
        var intersects = raycaster.intersectObjects( scene.children, true );

        return intersects.length > 0;
    }

    // sets them in row-major using a matrix in column-major
    function setMatrixFromArray(matrix, array) {
        matrix.set( array[0], array[4], array[8], array[12],
            array[1], array[5], array[9], array[13],
            array[2], array[6], array[10], array[14],
            array[3], array[7], array[11], array[15]
        );
    }

    function projectionMatrixFrom(vFOV, aspect, near, far) {
        var top = near * Math.tan((Math.PI / 180) * 0.5 * vFOV );
        var height = 2 * top;
        var width = aspect * height;
        var left = -0.5 * width;
        return makePerspective( left, left + width, top, top - height, near, far );
    }

    function makePerspective ( left, right, top, bottom, near, far ) {

        var te = [];
        var x = 2 * near / ( right - left );
        var y = 2 * near / ( top - bottom );

        var a = ( right + left ) / ( right - left );
        var b = ( top + bottom ) / ( top - bottom );
        var c = - ( far + near ) / ( far - near );
        var d = - 2 * far * near / ( far - near );


        te[ 0 ] = x;    te[ 4 ] = 0;    te[ 8 ] = a;    te[ 12 ] = 0;
        te[ 1 ] = 0;    te[ 5 ] = y;    te[ 9 ] = b;    te[ 13 ] = 0;
        te[ 2 ] = 0;    te[ 6 ] = 0;    te[ 10 ] = c;   te[ 14 ] = d;
        te[ 3 ] = 0;    te[ 7 ] = 0;    te[ 11 ] = - 1; te[ 15 ] = 0;

        return te;

    }

    function renderScene(modelViewMatrix, projectionMatrix) {
        if(mesh == undefined) return;
        
        // only set the projection matrix for the camera 1 time, since it stays the same
        if (!isProjectionMatrixSet && projectionMatrix.length > 0) {
            setMatrixFromArray(camera.projectionMatrix, projectionMatrix);
            isProjectionMatrixSet = true;
            //setNewProjectionMatrix(projectionMatrixFrom(25, -window.innerWidth/window.innerHeight, 400, 300000));
            var tempM = new THREE.Matrix4();
            tempM.getInverse(camera.projectionMatrix);
            //box.material.uniforms.projectionInverse.value = tempM;

        }

        if (isProjectionMatrixSet) { // don't turn into else statement, both can happen
            // update models with newest values from the reality editor
            //mesh.children[0].material.color.setHSL( hue, saturation, lightness );
            setMatrixFromArray(threejsContainerObj.matrix, modelViewMatrix);

            var testMatrix = new THREE.Matrix4();
            setMatrixFromArray(testMatrix, modelViewMatrix);
            var position = new THREE.Vector3();
            var scale = new THREE.Vector3();
            var rotation = new THREE.Quaternion();
            testMatrix.decompose(position,rotation,scale);
            testMatrix.compose(position,rotation, new THREE.Vector3(Math.sign(scale.x) * Math.abs(scale.z),scale.z,scale.z));
            setMatrixFromArray(threejsContainerObj.matrix, testMatrix.elements);



            // render the scene
            threejsContainerObj.visible = true;
            renderer.render( scene, camera );
        }
    }

    function addExperimentalCube(parent) {
        var uniforms = {
        colorB: {type: 'vec3', value: new THREE.Color(0xACB6E5)},
        colorA: {type: 'vec3', value: new THREE.Color(0x74ebd5)},
        radius: {type: 'vec3', value: new THREE.Vector3(800,10,10)},
        center: {type: 'vec3', value: new THREE.Vector3(0,0,0)},
        projectionInverse: {type: 'mat4', value: new THREE.Matrix4()}
        }

        var geometry = new THREE.BoxGeometry(900, 500, 600);

        for ( var i = 0; i < geometry.faces.length; i ++ ) {

            var face = geometry.faces[ i ];
            var temp = face.a;
            face.a = face.c;
            face.c = temp;

        }

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();

        var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
        for ( var i = 0; i < faceVertexUvs.length; i ++ ) {

            var temp = faceVertexUvs[ i ][ 0 ];
            faceVertexUvs[ i ][ 0 ] = faceVertexUvs[ i ][ 2 ];
            faceVertexUvs[ i ][ 2 ] = temp;

        }



        var materials = [
            new THREE.MeshPhongMaterial( { color: 0xffffff, shading: THREE.FlatShading, vertexColors: THREE.VertexColors, shininess: 0, transparent:true } )
        ];
        //aterial.blending = THREE.MultiplyBlending;

        //material.side = THREE.DoubleSide;

        var mesh = THREE.SceneUtils.createMultiMaterialObject( geometry, materials );

        var spotLight = new THREE.SpotLight(0xffffff);
        spotLight.position.set(-30, -30, 150);
        spotLight.castShadow = true;
        mesh.add(spotLight);
        //mesh.doubleSided = true;
        parent.add(mesh);
        mesh.position.setZ(150);
        mesh.updateMatrixWorld();
        return mesh;
    }

    function addExperimentalCubeOuter(parent) {
        var uniforms = {
        colorB: {type: 'vec3', value: new THREE.Color(0x000000)},
        colorA: {type: 'vec3', value: new THREE.Color(0x0097e6)},
        radius: {type: 'vec3', value: new THREE.Vector3(1300,10,10)},
        center: {type: 'vec3', value: new THREE.Vector3(0,0,0)},
        projectionInverse: {type: 'mat4', value: new THREE.Matrix4()}
        }

        console.log('Setting box size');
       
        var geometry = new THREE.BoxGeometry(900, 500, 650 * 1.5);




        var material =  new THREE.ShaderMaterial({
            uniforms: uniforms,
            fragmentShader: fragmentShader2(),
            vertexShader: vertexShader(),
        });
        material.transparent = true;
        material.blending = THREE.MultiplyBlending;

        //material.side = THREE.DoubleSide;

        var mesh = new THREE.Mesh(geometry, material);
        //mesh.doubleSided = true;
        parent.add(mesh);
        mesh.position.setZ(150);
        mesh.updateMatrixWorld();
        return mesh;
    }

    function vertexShader() {
        return `
        varying vec3 vUv; 
        uniform  vec3 center;
        uniform vec3 radius;
        varying vec3 r;
        void main() {
          vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
          gl_Position = projectionMatrix * modelViewPosition; 
          vUv = (modelMatrix * vec4(position, 1.0)).xyz;


        }`;
    }


    function fragmentShader2() {
            return `
      uniform vec3 colorA; 
      uniform vec3 colorB;
      uniform  vec3 center;
      uniform vec3 radius;
      varying vec3 vUv;
      varying vec3 r;


      void main() {

        float formula = (vUv.x - center.x) * (vUv.x - center.x) + (vUv.y - center.y) * (vUv.y - center.y)  + (vUv.z - center.z) * (vUv.z - center.z)  - radius.x * radius.x;
        float alpha = 0.0;
          if(formula < 0.0) {
            alpha = 1.0;
            gl_FragColor = vec4(vec3(1.0,1.0,1.0), alpha);

          } else {
            alpha = 1.0;
            gl_FragColor = vec4(vec3(0.0,0.0,0.0), 0.0);

          }


      }

            `;

    }

    function fragmentShader() {
            return `
      uniform vec3 colorA; 
      uniform vec3 colorB;
      uniform  vec3 center;
      uniform vec3 radius;
      varying vec3 vUv;
      varying vec3 r;


      void main() {

        float formula = (vUv.x - center.x) * (vUv.x - center.x) + (vUv.y - center.y) * (vUv.y - center.y)  + (vUv.z - center.z) * (vUv.z - center.z)  - radius.x * radius.x;
        float alpha = 0.0;
          if(formula < 0.0) {
            alpha = 1.0;
          } else {
            alpha = 1.0;
          }


        gl_FragColor = vec4(vec3(0.0,0.0,1.0), alpha);
      }

            `;

    }

</script>
</body>
</html>
