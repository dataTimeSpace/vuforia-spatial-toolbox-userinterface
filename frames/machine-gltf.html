<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>THREE.js Sphere</title>
    <script src="resources/object-frames.js"></script>
    <script src="resources/pep.min.js"></script>
    <!--<script src="resources/navigation-arrow.js"></script>-->
    <!--<link rel="stylesheet" type="text/css" href="resources/navigation-arrow.css">-->
    <script src="resources/threejs-src/2018/three.min.js"></script>
    <script src="resources/threejs-src/2018/loaders/GLTFLoader.js"></script>
</head>
<body>
<script>
    var camera, scene, renderer;
    
    var loader;

    var threejsContainerObj;
    var realityInterface;

    var isProjectionMatrixSet = false;

    var rendererWidth = screen.height;
    var rendererHeight = screen.width;
    var aspectRatio = rendererWidth / rendererHeight;

    var clock = new THREE.Clock();

    window.addEventListener('load', function() {

        // create a fullscreen webgl renderer for the threejs content and add to the dom
        renderer = new THREE.WebGLRenderer( { alpha: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( rendererWidth, rendererHeight );
        document.body.appendChild( renderer.domElement );

        // create a threejs camera and scene
        camera = new THREE.PerspectiveCamera( 70, aspectRatio, 0.00001, Infinity );
        scene = new THREE.Scene();

        // create a parent 3D object to contain all the three js objects
        // we can apply the marker transform to this object and all of its
        // children objects will be affected
        threejsContainerObj = new THREE.Object3D();
        threejsContainerObj.matrixAutoUpdate = false;
        scene.add(threejsContainerObj);
        
        // Add the GLTF model to the scene
        loader = new THREE.GLTFLoader();

        loader.load(
            // resource URL
            './resources/models/machine/scene.gltf',

            // called when the resource is loaded
            function ( gltf ) {
                
                // fix upside-down model
                var rotation = new THREE.Matrix4().makeRotationZ(Math.PI);
                gltf.scene.applyMatrix(rotation);
                
                threejsContainerObj.add( gltf.scene );
                
                console.log( gltf.animations, gltf.scene, gltf.scenes, gltf.cameras, gltf.asset );

                mixer = new THREE.AnimationMixer(gltf.scene);
                mixer.clipAction(gltf.animations[0]).play();
                
                startAnimation();
            },
            // called while loading is progressing
            function ( xhr ) {

                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

            },
            // called when loading has errors
            function ( error ) {

                console.log( 'An error happened' );

            }
        );
        
        // light for the scene
        var light = new THREE.HemisphereLight( 0xffffff, 0x444444 );
        light.position.set( 0, 200, 0 );
        scene.add( light );
        light = new THREE.DirectionalLight( 0xffffff );
        light.position.set( 0, 200, 100 );
        light.castShadow = true;
        light.shadow.camera.top = 180;
        light.shadow.camera.bottom = -100;
        light.shadow.camera.left = -120;
        light.shadow.camera.right = 120;
        scene.add( light );
        
        // make the frame fullscreen within the reality editor,
        // and subscribe to the modelview and projection matrices
        realityInterface = new RealityInterface();
        realityInterface.subscribeToMatrix();
        realityInterface.setFullScreenOn();

        realityInterface.setMoveDelay(400);

        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2(), INTERSECTED;

        realityInterface.registerTouchDecider(function(eventData) {
            //1. sets the mouse position with a coordinate system where the center
            //   of the screen is the origin
            mouse.x = ( eventData.x / window.innerWidth ) * 2 - 1;
            mouse.y = - ( eventData.y / window.innerHeight ) * 2 + 1;

            //2. set the picking ray from the camera position and mouse coordinates
            raycaster.setFromCamera( mouse, camera );

            //3. compute intersections
            var intersects = raycaster.intersectObjects( scene.children, true );

            return intersects.length > 0;
        });

    });

    function startAnimation() {
        // whenever we receive new matrices from the editor, update the 3d scene
        realityInterface.addMatrixListener(renderScene);
    }

    function setMatrixFromArray(matrix, array) {
        matrix.set( array[0], array[4], array[8], array[12],
            array[1], array[5], array[9], array[13],
            array[2], array[6], array[10], array[14],
            array[3], array[7], array[11], array[15]
        );
    }

    function renderScene(modelViewMatrix, projectionMatrix) {
        // only set the projection matrix for the camera 1 time, since it stays the same
        if (!isProjectionMatrixSet && projectionMatrix.length > 0) {
            setMatrixFromArray(camera.projectionMatrix, projectionMatrix);
            isProjectionMatrixSet = true;
        }

        if (isProjectionMatrixSet) { // don't turn into else statement, both can happen
            setMatrixFromArray(threejsContainerObj.matrix, modelViewMatrix);

            // var translation = new THREE.Vector3();
            // var rotation = new THREE.Quaternion();
            // var scale = new THREE.Vector3();
            // threejsContainerObj.matrix.decompose(translation, rotation, scale);
            // // // console.log(scale);
            // threejsContainerObj.children.forEach(function(child) {
            //     child.matrix = new THREE.Matrix4();
            // //     // setMatrixFromArray(child.matrix, [scale.x, 0, 0, 0, 0, scale.y, 0, 0, 0, 0, scale.z, 0, 0, 0, 0, 1]);
            // //     child.applyMatrix(new THREE.Matrix4().makeTranslation(-translation.x, -translation.y, -translation.z));
            //     child.applyMatrix(new THREE.Matrix4().makeRotationZ(Math.PI));
            // //     child.applyMatrix(new THREE.Matrix4().makeTranslation(translation.x, translation.y, translation.z));
            // //     // child.applyMatrix(new THREE.Matrix4().makeTranslation(translation.x*scale.x, translation.y*scale.y, translation.z*scale.z));
            //     child.applyMatrix(new THREE.Matrix4().makeScale(scale.x, scale.y, scale.z));
            // });

            var delta = clock.getDelta();
            if (mixer != null) {
                mixer.update(delta);
            }
            renderer.render( scene, camera );
        }
    }

</script>
</body>
</html>
