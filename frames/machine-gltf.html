<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>THREE.js Sphere</title>
    <script src="resources/object-frames.js"></script>
    <script src="resources/pep.min.js"></script>
    <!--<script src="resources/navigation-arrow.js"></script>-->
    <!--<link rel="stylesheet" type="text/css" href="resources/navigation-arrow.css">-->
    <script src="resources/threejs-src/2018/three.min.js"></script>
    <script src="resources/threejs-src/2018/loaders/GLTFLoader.js"></script>
    <style>
        .sequenceButton {
            border: 2px solid cyan;
            position: absolute;
            bottom: 2px;
            font-size: 20px;
            font-family: "Futura", Helvetica Neue, Helvetica, Arial, sans-serif;
            /*padding: 10px;*/
            color: cyan;
            text-align: center;
            width: 56px;
            height: 56px;
            line-height: 56px;
            /*background-color: rgba(0,255,255,0.3);*/
        }
        
        #prevButton {
            left: 0;
        }
        
        #nextButton {
            right: 62px;
        }
        
        #playButton {
            width: 160px;
            left: 173px;
            /*right: 384px;*/
        }
        
        .hidden {
            display: none;
        }
        
    </style>
</head>
<body>
<div id="prevButton" class="sequenceButton hidden"> << </div>
<div id="nextButton" class="sequenceButton hidden"> >> </div>
<div id="playButton" class="sequenceButton hidden"> PLAY </div>
    
<script>
    var camera, scene, renderer;
    
    var loader;

    var threejsContainerObj;
    var realityInterface;

    var isProjectionMatrixSet = false;

    var rendererWidth = screen.height;
    var rendererHeight = screen.width;
    var aspectRatio = rendererWidth / rendererHeight;

    var clock = new THREE.Clock();
    var currentStep = 0;
    var timestamps = [0, 6.0, 9.25, 11.5]; // [0, 3, 6, 9, 12, 15]; // 
    var animationDuration;
    var animationAction;
    
    var isPaused = true;

    window.addEventListener('load', function() {

        // create a fullscreen webgl renderer for the threejs content and add to the dom
        renderer = new THREE.WebGLRenderer( { alpha: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( rendererWidth, rendererHeight );
        document.body.appendChild( renderer.domElement );
        // renderer.domElement.style.zIndex = '-1';

        // create a threejs camera and scene
        camera = new THREE.PerspectiveCamera( 70, aspectRatio, 0.00001, Infinity );
        scene = new THREE.Scene();

        // create a parent 3D object to contain all the three js objects
        // we can apply the marker transform to this object and all of its
        // children objects will be affected
        threejsContainerObj = new THREE.Object3D();
        threejsContainerObj.matrixAutoUpdate = false;
        scene.add(threejsContainerObj);
        
        // Add the GLTF model to the scene
        loader = new THREE.GLTFLoader();

        loader.load(
            // resource URL
            './resources/models/machine/scene.gltf',

            // called when the resource is loaded
            function ( gltf ) {
                
                // fix upside-down model
                var rotation = new THREE.Matrix4().makeRotationZ(Math.PI);
                gltf.scene.applyMatrix(rotation);
                var bbox = new THREE.Box3().setFromObject(gltf.scene);
                var translation = new THREE.Matrix4().makeTranslation(0, (bbox.max.y - bbox.min.y)/200, 0);
                gltf.scene.applyMatrix(translation);
                
                threejsContainerObj.add( gltf.scene );
                
                console.log( gltf.animations, gltf.scene, gltf.scenes, gltf.cameras, gltf.asset );

                mixer = new THREE.AnimationMixer(gltf.scene);
                animationAction = mixer.clipAction(gltf.animations[0]);
                animationDuration = gltf.animations[0].duration;
                animationAction.play();
                clock.stop(); // begin paused

                document.getElementById('playButton').classList.remove('hidden');
                document.getElementById('prevButton').classList.remove('hidden');
                document.getElementById('nextButton').classList.remove('hidden');
                updateButtons();

                startAnimation();
            },
            // called while loading is progressing
            function ( xhr ) {

                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

            },
            // called when loading has errors
            function ( error ) {

                console.log( 'An error happened' );

            }
        );
        
        // light for the scene
        var light = new THREE.HemisphereLight( 0xffffff, 0x444444 );
        light.position.set( 0, 200, 0 );
        scene.add( light );
        light = new THREE.DirectionalLight( 0xffffff );
        light.position.set( 0, 200, 100 );
        light.castShadow = true;
        light.shadow.camera.top = 180;
        light.shadow.camera.bottom = -100;
        light.shadow.camera.left = -120;
        light.shadow.camera.right = 120;
        scene.add( light );
        // add spotlight for the shadows
        var spotLight = new THREE.SpotLight(0xffffff);
        spotLight.position.set(-30, -30, 150);
        spotLight.castShadow = true;
        scene.add(spotLight);
        scene.add( new THREE.AmbientLight( 0x666666 ) );

        // make the frame fullscreen within the reality editor,
        // and subscribe to the modelview and projection matrices
        realityInterface = new RealityInterface();
        realityInterface.subscribeToMatrix();
        realityInterface.setFullScreenOn();

        realityInterface.setMoveDelay(400);

        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2(), INTERSECTED;

        realityInterface.registerTouchDecider(function(eventData) {
            
            if (document.elementFromPoint(eventData.x, eventData.y) && document.elementFromPoint(eventData.x, eventData.y).tagName !== 'CANVAS') {
                console.log('hit real dom element within this fullscreen div');
                return true;
            }
            
            //1. sets the mouse position with a coordinate system where the center
            //   of the screen is the origin
            mouse.x = ( eventData.x / window.innerWidth ) * 2 - 1;
            mouse.y = - ( eventData.y / window.innerHeight ) * 2 + 1;

            //2. set the picking ray from the camera position and mouse coordinates
            raycaster.setFromCamera( mouse, camera );

            //3. compute intersections
            var intersects = raycaster.intersectObjects( scene.children, true );

            return intersects.length > 0;
        });

        document.getElementById('prevButton').addEventListener('pointerup', function(e) {
            console.log('prevButton pressed');
            if (currentStep > 0) {
                currentStep -= 1;
            }
            animationAction.time = timestamps[currentStep];
            updateButtons();
            // clock.start();
        });
        
        document.getElementById('nextButton').addEventListener('pointerup', function(e) {
            console.log('nextButton pressed');
            if (currentStep < timestamps.length-1) {
                currentStep += 1;
            }
            animationAction.time = timestamps[currentStep];
            updateButtons();
            // clock.start();
        });
        
        document.getElementById('playButton').addEventListener('pointerup', function(e) {
            console.log('playButton pressed');
            
            // isPaused = !isPaused;
            
            setPaused(!isPaused);
            
            // console.log('time = ' + animationAction.time);
            //
            // if (isPaused) {
            //     document.getElementById('playButton').innerHTML = 'PLAY';
            //     clock.stop();
            // } else {
            //     document.getElementById('playButton').innerHTML = 'PAUSE';
            //     // mixer.time = 0;
            //     // animationAction.time = 0;
            //     clock.start();
            // }
        });

    });
    
    function setPaused(_isPaused) {
        isPaused = _isPaused;
        
        console.log('time = ' + animationAction.time);
        
        updateButtons();

        if (isPaused) {
            clock.stop();
        } else {
            clock.start();
        }
    }

    function startAnimation() {
        // whenever we receive new matrices from the editor, update the 3d scene
        realityInterface.addMatrixListener(renderScene);
    }

    function setMatrixFromArray(matrix, array) {
        matrix.set( array[0], array[4], array[8], array[12],
            array[1], array[5], array[9], array[13],
            array[2], array[6], array[10], array[14],
            array[3], array[7], array[11], array[15]
        );
    }

    function renderScene(modelViewMatrix, projectionMatrix) {
        // only set the projection matrix for the camera 1 time, since it stays the same
        if (!isProjectionMatrixSet && projectionMatrix.length > 0) {
            setMatrixFromArray(camera.projectionMatrix, projectionMatrix);
            isProjectionMatrixSet = true;
        }

        if (isProjectionMatrixSet) { // don't turn into else statement, both can happen
            setMatrixFromArray(threejsContainerObj.matrix, modelViewMatrix);
            
            var newStep = getStepFromTimestamps(animationAction, timestamps);
            if (newStep !== currentStep) {
                currentStep = newStep;
                console.log('reached step ' + currentStep);
                // clock.stop();
                setPaused(true);
            }
            
            // if (!isPaused) {
                var delta = clock.getDelta();
                if (mixer != null) {
                    mixer.update(delta);
                }
            // }

            renderer.render( scene, camera );
        }
    }
    
    function getStepFromTimestamps(action, timestampArray) {
        var stepReached = 0;
        var currentTime = action.time;
        for (var i = 0; i < timestampArray.length; i++) {
            if (currentTime >= timestampArray[i]) {
                stepReached = i;
            }
        }
        return stepReached;
    }
    
    function updateButtons() {
        if (isPaused) {
            document.getElementById('playButton').innerHTML = 'PLAY (' + (currentStep + 1) + '/' + timestamps.length + ')';
        } else {
            document.getElementById('playButton').innerHTML = 'PAUSE (' + (currentStep+1) + '/' + timestamps.length + ')';
        }
    }

</script>
</body>
</html>
