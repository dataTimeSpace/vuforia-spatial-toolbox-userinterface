<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>THREE.js Sphere</title>
    <script src="objectDefaultFiles/object.js"></script>
    <script src="objectDefaultFiles/pep.min.js"></script>
    <script src="resources/threejs-src/2018/three.min.js"></script>
    <script src="resources/threejs-src/2018/libs/inflate.min.js"></script>
    <script src="resources/threejs-src/2018/loaders/FBXLoader.js"></script>
</head>
<body>
<script>
    var camera, scene, renderer;
    
    var loader;

    var threejsContainerObj;
    var realityInterface;

    var isProjectionMatrixSet = false;

    var rendererWidth = screen.height;
    var rendererHeight = screen.width;
    var aspectRatio = rendererWidth / rendererHeight;

    var clock = new THREE.Clock();

    var mixers = [];

    window.addEventListener('load', function() {

        // create a fullscreen webgl renderer for the threejs content and add to the dom
        renderer = new THREE.WebGLRenderer( { alpha: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( rendererWidth, rendererHeight );
        document.body.appendChild( renderer.domElement );

        // create a threejs camera and scene
        camera = new THREE.PerspectiveCamera( 70, aspectRatio, 1, 1000 );
        scene = new THREE.Scene();

        // create a parent 3D object to contain all the three js objects
        // we can apply the marker transform to this object and all of its
        // children objects will be affected
        threejsContainerObj = new THREE.Object3D();
        threejsContainerObj.matrixAutoUpdate = false;
        scene.add(threejsContainerObj);

        // model
        loader = new THREE.FBXLoader();
        
        loader.load( './resources/models/fbx/Samba Dancing.fbx', function ( object ) {

            // fix upside-down model
            var rotation = new THREE.Matrix4().makeRotationZ(Math.PI);
            object.applyMatrix(rotation);
            
            object.mixer = new THREE.AnimationMixer( object );
            mixers.push( object.mixer );
            var action = object.mixer.clipAction( object.animations[ 0 ] );
            action.play();
            object.traverse( function ( child ) {
                if ( child.isMesh ) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            } );
            threejsContainerObj.add( object );
            startAnimation();
        } );

        // light for the scene
        var light = new THREE.HemisphereLight( 0xffffff, 0x444444 );
        light.position.set( 0, 200, 0 );
        scene.add( light );
        light = new THREE.DirectionalLight( 0xffffff );
        light.position.set( 0, 200, 100 );
        light.castShadow = true;
        light.shadow.camera.top = 180;
        light.shadow.camera.bottom = -100;
        light.shadow.camera.left = -120;
        light.shadow.camera.right = 120;
        scene.add( light );

        // make the frame fullscreen within the reality editor,
        // and subscribe to the modelview and projection matrices
        realityInterface = new RealityInterface();
        realityInterface.subscribeToMatrix();
        realityInterface.setFullScreenOn();

        realityInterface.setMoveDelay(400);

        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2(), INTERSECTED;

        realityInterface.registerTouchDecider(function(eventData) {
            //1. sets the mouse position with a coordinate system where the center
            //   of the screen is the origin
            mouse.x = ( eventData.x / window.innerWidth ) * 2 - 1;
            mouse.y = - ( eventData.y / window.innerHeight ) * 2 + 1;

            //2. set the picking ray from the camera position and mouse coordinates
            raycaster.setFromCamera( mouse, camera );

            //3. compute intersections
            var intersects = raycaster.intersectObjects( scene.children, true );

            return intersects.length > 0;
        });

    });

    function startAnimation() {
        // whenever we receive new matrices from the editor, update the 3d scene
        realityInterface.addMatrixListener(renderScene);
    }

    function setMatrixFromArray(matrix, array) {
        matrix.set( array[0], array[4], array[8], array[12],
            array[1], array[5], array[9], array[13],
            array[2], array[6], array[10], array[14],
            array[3], array[7], array[11], array[15]
        );
    }

    function renderScene(modelViewMatrix, projectionMatrix) {
        // only set the projection matrix for the camera 1 time, since it stays the same
        if (!isProjectionMatrixSet && projectionMatrix.length > 0) {
            setMatrixFromArray(camera.projectionMatrix, projectionMatrix);
            isProjectionMatrixSet = true;
        }

        if (isProjectionMatrixSet) { // don't turn into else statement, both can happen

            if ( mixers.length > 0 ) {
                for ( var i = 0; i < mixers.length; i ++ ) {
                    mixers[ i ].update( clock.getDelta() );
                }
            }

            setMatrixFromArray(threejsContainerObj.matrix, modelViewMatrix);
            renderer.render( scene, camera );
        }
    }

</script>
</body>
</html>
